<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Micro-benchmarking</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/theme/night.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//css/ucl_reveal.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//site-styles/reveal.css"/>
  <link rel="stylesheet" media="print" href="http://lab.hakim.se/reveal-js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="http://lab.hakim.se/reveal-js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Micro-benchmarking</h1>
    <h3 class="date"></h3>
</section>

<section id="micro-benchmarking" class="slide level2">
<h1>Micro-benchmarking</h1>
<p>meaningful bit of code, and systematically run performance tests for each Scientific method applied to performance: measure the time taken by each commit.</p>
<p>Profiling can tell us what part to include in a benchmark.</p>
<p>Possible micro-benchmarking frameworks:</p>
<ul>
<li>timers in unit test framework (not really accurate)</li>
<li><a href="https://github.com/google/benchmark">google/benchmark</a></li>
<li><a href="https://github.com/nickbruun/hayai">hayai</a>, a &quot;google-test&quot;-like framework</li>
<li><a href="http://www.bfilipek.com/2016/01/micro-benchmarking-libraries-for-c.html">others</a></li>
</ul>
<p>Questions micro-benchmarking can answer:</p>
<ol type="1">
<li>How long does it take on average</li>
<li>Standard-deviation from average</li>
<li>Worst case</li>
</ol>
<p>Questions it doesn't always answer:</p>
<ol type="1">
<li>Performance of large subsets or whole application</li>
<li>Parallelization: communication vs computation</li>
</ol>
</section>
<section id="exercise-build-and-run-micro_benchmark" class="slide level2">
<h1>Exercise: build and run <code>micro_benchmark</code></h1>
<p><code>micro_benchmark</code> reproduces the evaluation function from the travelling salesman problem.</p>
<p>It reproduces how a micro-benchmark framework works:</p>
<ol type="1">
<li>run code N times for warm-up</li>
<li>run code N' times for actual measurement</li>
</ol>
<p>Make sure the code is built in <code>Release</code> mode.</p>
<p>Questions:</p>
<ol type="1">
<li>Why is the float implementation faster/slower? Does the speed-up change with the number of dimensions or the number of cities? What happens for Nrow = 3?</li>
<li>Write a function that computes the distance manually (without Eigen syntactic sugar). It it faster for Nrows=2? What about Nrows=8?</li>
</ol>
<p>Remark:</p>
<p>None of these have tests (this is an exercise in bad code, after all). Do you trust we are solving the travelling salesman problem? I <em>know</em> that <code>awful</code> does not, beyond the memory bugs... Because I added a bug. But maybe there are further bugs still.</p>
<p>How much easier would it be to test the <code>manual</code> code above if we had tests for the evaluation function?</p>
</section>
    </div>
  </div>

  <script src="http://lab.hakim.se/reveal-js/lib/js/head.min.js"></script>
  <script src="http://lab.hakim.se/reveal-js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'night', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'http://lab.hakim.se/reveal-js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'http://lab.hakim.se/reveal-js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'http://lab.hakim.se/reveal-js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
