<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Point to Point</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; }
code > span.dt { color: #dfdfbf; }
code > span.dv { color: #dcdccc; }
code > span.bn { color: #dca3a3; }
code > span.fl { color: #c0bed1; }
code > span.ch { color: #dca3a3; }
code > span.st { color: #cc9393; }
code > span.co { color: #7f9f7f; }
code > span.ot { color: #efef8f; }
code > span.al { color: #ffcfaf; }
code > span.fu { color: #efef8f; }
code > span.er { color: #c3bf9f; }
    </style>
    <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/theme/night.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//css/ucl_reveal.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//site-styles/reveal.css"/>
  <link rel="stylesheet" media="print" href="http://lab.hakim.se/reveal-js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="http://lab.hakim.se/reveal-js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Point to Point</h1>
    <h3 class="date"></h3>
</section>

<section><section id="point-to-point-communication" class="titleslide slide level2"><h1>Point to point communication</h1></section><section id="many-point-2-point-communication-schemes" class="slide level3">
<h1>Many point-2-point communication schemes</h1>
<p>Can you think of two behaviours for message passing?</p>
<figure>
<img src="figures/mpi.png" />
</figure>
<ul>
<li>Process 0 can (i) give message and then either (ii) leave or (iii) wait for acknowledgements</li>
<li>Process 1 can (i) receive message</li>
<li>MPI can (i) receive message, (ii) deliver message, (iii) deliver acknowledgments</li>
</ul>
</section><section id="blocking-synchronous-send" class="slide level3">
<h1>Blocking synchronous send</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Stage</th>
<th style="text-align: left;">Figure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">a. 0, 1, and MPI stand ready:</td>
<td style="text-align: left;"><img src="figures/sync0.png" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">b. message dropped off by 0:</td>
<td style="text-align: left;"><img src="figures/sync1.png" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">c. transit:</td>
<td style="text-align: left;"><img src="figures/syncT.png" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">d. message received by 1</td>
<td style="text-align: left;"><img src="figures/syncA.png" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">e. receipt received by 0</td>
<td style="text-align: left;"><img src="figures/syncR.png" /></td>
</tr>
</tbody>
</table>
</section><section id="blocking-send" class="slide level3">
<h1>Blocking send</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Stage</th>
<th style="text-align: left;">Figure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">a. 0, 1, and MPI stand ready:</td>
<td style="text-align: left;"><img src="figures/sync0.png" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">b. message dropped off by 0:</td>
<td style="text-align: left;"><img src="figures/sync1.png" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">c. transit, 0 leaves</td>
<td style="text-align: left;"><img src="figures/ssyncT.png" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">d. message received by 1</td>
<td style="text-align: left;"><img src="figures/ssyncA.png" /></td>
</tr>
</tbody>
</table>
</section><section id="non-blocking-send" class="slide level3">
<h1>Non-blocking send</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Stage</th>
<th style="text-align: left;">Figure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">a. 0, 1, and MPI stand ready:</td>
<td style="text-align: left;"><img src="figures/async0.png" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">b. 0 leaves message in safebox</td>
<td style="text-align: left;"><img src="figures/async1.png" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">c. transit</td>
<td style="text-align: left;"><img src="figures/asyncT.png" /></td>
</tr>
<tr class="even">
<td style="text-align: left;">d. message received by 1</td>
<td style="text-align: left;"><img src="figures/asyncA.png" /></td>
</tr>
<tr class="odd">
<td style="text-align: left;">e. receipt placed in safebox</td>
<td style="text-align: left;"><img src="figures/asyncR.png" /></td>
</tr>
</tbody>
</table>
</section><section id="blocking-synchronous-send-1" class="slide level3">
<h1>Blocking synchronous send</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> MPI_Ssend(<span class="dt">const</span> <span class="dt">void</span> *buf, <span class="dt">int</span> count, MPI_Datatype datatype, <span class="dt">int</span> dest, <span class="dt">int</span> tag,
              MPI_Comm comm)</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">buf</td>
<td style="text-align: left;">Pointer to buffer. Always <code>void</code> because practical C is not type safe.</td>
</tr>
<tr class="even">
<td style="text-align: left;">count</td>
<td style="text-align: left;">Size of the buffer. I.e. length of the message to send, in units of the specified datatype (not bytes)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">datatype</td>
<td style="text-align: left;">Encodes type of the buffer. <code>MPI_INT</code> for integers, <code>MPI_CHAR</code> for characters. Lots of others.</td>
</tr>
<tr class="even">
<td style="text-align: left;">dest</td>
<td style="text-align: left;">Rank of the <em>receiving</em> process</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tag</td>
<td style="text-align: left;">A tag for message book-keeping</td>
</tr>
<tr class="even">
<td style="text-align: left;">comm</td>
<td style="text-align: left;">The communicator -- usually just <code>MPI_COMM_WORLD</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">return</td>
<td style="text-align: left;">An error tag. Equals <code>MPI_SUCCESS</code> on success.</td>
</tr>
</tbody>
</table>
</section><section id="blocking-receive" class="slide level3">
<h1>Blocking receive</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> MPI_Recv(<span class="dt">void</span> *buf, <span class="dt">int</span> count, MPI_Datatype datatype, <span class="dt">int</span> source, <span class="dt">int</span> tag,
             MPI_Comm comm, MPI_Status *status)</code></pre>
<p>Good for both synchronous and asynchonous communication</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">buf</td>
<td style="text-align: left;">Pointer to receiving <em>pre-allocated</em> buffer</td>
</tr>
<tr class="even">
<td style="text-align: left;">count</td>
<td style="text-align: left;">Size of the buffer. I.e. maximum length of the message to receive. See <code>MPI_Get_count</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">datatype</td>
<td style="text-align: left;">Informs on the type of the buffer</td>
</tr>
<tr class="even">
<td style="text-align: left;">source</td>
<td style="text-align: left;">Rank of the <em>sending</em> process</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tag</td>
<td style="text-align: left;">A tag for message book-keeping</td>
</tr>
<tr class="even">
<td style="text-align: left;">status</td>
<td style="text-align: left;">`MPI_STATUS_IGNORE<code>for now. See</code>MPI_Get_count``.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">comm</td>
<td style="text-align: left;">The communicator</td>
</tr>
<tr class="even">
<td style="text-align: left;">return</td>
<td style="text-align: left;">Error tag</td>
</tr>
</tbody>
</table>
</section><section id="example-blocking-synchronous-example" class="slide level3">
<h1>Example: Blocking synchronous example</h1>
<p>Inside a new section in the test framework:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
      std::string <span class="dt">const</span> peace = <span class="st">&quot;I come in peace!&quot;</span>;
      <span class="kw">if</span>(rank == <span class="dv">0</span>) {
         <span class="dt">int</span> <span class="dt">const</span> error = MPI_Ssend(
           (<span class="dt">void</span>*) peace.c_str(), peace.size() + <span class="dv">1</span>, MPI_CHAR, <span class="dv">1</span>, <span class="dv">42</span>, MPI_COMM_WORLD);
         <span class="co">// Here, we guarantee that Rank 1 has received the message.</span>
         REQUIRE(error ==  MPI_SUCCESS);
      }
      <span class="kw">if</span>(rank == <span class="dv">1</span>) {
          <span class="dt">char</span> buffer[<span class="dv">256</span>];
          <span class="dt">int</span> <span class="dt">const</span> error = MPI_Recv(
            buffer, <span class="dv">256</span>, MPI_CHAR, <span class="dv">0</span>, <span class="dv">42</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
          REQUIRE(error ==  MPI_SUCCESS);
          CHECK(std::string(buffer) == peace);
      }</code></pre>
<p>Common bug: Set both sender and receiver to 0. What happens?</p>
</section><section id="example-do-you-know-your-c-vs-c-strings" class="slide level3">
<h1>Example: Do you know your C vs C++ strings?</h1>
<p>Why the <code>+1</code>?</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> <span class="dt">const</span> error = MPI_Ssend(
  (<span class="dt">void</span>*) peace.c_str(), peace.size() + <span class="dv">1</span>, MPI_CHAR, <span class="dv">1</span>, <span class="dv">42</span>, MPI_COMM_WORLD);</code></pre>
<div class="fragment">
<p>Because C and C++ <code>char const*</code> strings are null-terminated to indicate the string is finished, which adds an extra character. However, <code>std::string</code> abstracts it away. And so its length does <em>not</em> include the null-termination.</p>
</div>
</section><section id="example-causing-a-dead-lock" class="slide level3">
<h1>Example: Causing a dead-lock</h1>
<p>Watch out for order of send and receive!</p>
<p>Bad:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span>(rank == <span class="dv">0</span>) {
   MPI_Ssend (sendbuf, count, MPI_INT, <span class="dv">1</span>, tag, comm);
   MPI_Recv (recvbuf, count, MPI_INT, <span class="dv">1</span>, tag, comm, &amp;status);
} <span class="kw">else</span> {
   MPI_Ssend (sendbuf, count, MPI_INT, <span class="dv">0</span>, tag, comm);
   MPI_Recv (recvbuf, count, MPI_INT, <span class="dv">0</span>, tag, comm, &amp;status);
}</code></pre>
<p>Good:</p>
<pre><code>if(rank == 0) {
   MPI_Ssend (sendbuf, count, MPI_INT, 1, tag, comm);
   MPI_Recv (recvbuf, count, MPI_INT, 1, tag, comm, &amp;status);
} else {
   MPI_Recv (recvbuf, count, MPI_INT, 0, tag, comm, &amp;status);
   MPI_Ssend (sendbuf, count, MPI_INT, 0, tag, comm);
}</code></pre>
</section><section id="send-vs-ssend" class="slide level3">
<h1>Send vs SSend</h1>
<p>Why would we use Send instead of SSend?</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
      std::string peace = <span class="st">&quot;I come in peace!&quot;</span>;
      <span class="kw">if</span>(rank == <span class="dv">0</span>) {
         <span class="dt">int</span> <span class="dt">const</span> error = MPI_Send(
           (<span class="dt">void</span>*) peace.c_str(), peace.size() + <span class="dv">1</span>, MPI_CHAR, <span class="dv">1</span>, <span class="dv">42</span>, MPI_COMM_WORLD);
         <span class="co">// We do not guarantee that Rank 1 has received the message yet</span>
         <span class="co">// But nor do we necessarily know it hasn&#39;t.</span>
         <span class="co">// But we are definitely allowed to change the string, as MPI promises</span>
         <span class="co">// it has been buffered</span>
         peace = <span class="st">&quot;Shoot to kill!&quot;</span>; <span class="co">// Safe to reuse the send buffer.</span>
         REQUIRE(error ==  MPI_SUCCESS);
      }
      <span class="kw">if</span>(rank == <span class="dv">1</span>) {
          <span class="dt">char</span> buffer[<span class="dv">256</span>];
          <span class="dt">int</span> <span class="dt">const</span> error = MPI_Recv(
            buffer, <span class="dv">256</span>, MPI_CHAR, <span class="dv">0</span>, <span class="dv">42</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
          REQUIRE(error ==  MPI_SUCCESS);
          CHECK(std::string(buffer) == peace);
      }</code></pre>
<p>Both guarantee the buffer is safe to reuse. Send makes no guarantee as to whether it returns early or not. But <em>SSend</em> forces a <em>synchronisation point</em>: the codes reach the matching places, with all processes waiting until all reach that point.</p>
<p>It may come out slightly faster to use Send, since having a <strong>synchronisation point</strong> when you don't need one can slow things down: Suppose (A) runs slightly faster, then (B) does; at the end, they've both been running fully efficiently.</p>
<figure>
<img src="figures/efficient.png" />
</figure>
<p>Wth a synchronisation point in between, you'll have wasted time:</p>
<figure>
<img src="figures/inefficient.png" />
</figure>
<p>This is only important when there is noise or variability in the execution time on different processes, but this is often the case.</p>
<p>So unnecessary synchronisation points are bad. The MPI Implementation may choose to buffer, or synchronise in Send; you're letting MPI guess.</p>
<p>However, if you want to fine tune this to get the best performance, you should use ISend.</p>
</section><section id="non-blocking-isendirecv" class="slide level3">
<h1>Non-blocking: ISend/IRecv</h1>
<p>With ISend, we indicate when we want the message to set off.</p>
<p>We receive a handle to the message, of type <code>MPI_Request*</code> which we can use to require it has been received, or check.</p>
<p>This produces more complicated code, but you can write code which <strong>overlaps calculation with communication</strong>: the message is travelling, while you get on with something else. We'll see a practical example of using this next lecture.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
        std::string peace = <span class="st">&quot;I come in peace!&quot;</span>;
        <span class="kw">if</span>(rank == <span class="dv">0</span>) {
          MPI_Request request;
           <span class="dt">int</span> error = MPI_Isend(
             (<span class="dt">void</span>*) peace.c_str(), peace.size() + <span class="dv">1</span>, MPI_CHAR, <span class="dv">1</span>, <span class="dv">42</span>,
             MPI_COMM_WORLD, &amp;request);
           <span class="co">// We do not guarantee that Rank 1 has received the message yet</span>
           <span class="co">// We can carry on, and ANY WORK WE DO NOW WILL OVERLAP WITH THE</span>
           <span class="co">// COMMUNICATION</span>
           <span class="co">// BUT, we can&#39;t safely change the string.</span>
           REQUIRE(error ==  MPI_SUCCESS);
           <span class="co">// Do some expensive work here</span>
           <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">1000</span>; i++) {}; <span class="co">// BUSYNESS FOR EXAMPLE</span>
           MPI_Status status;
           error = MPI_Wait(&amp;request, &amp;status);
           REQUIRE(error ==  MPI_SUCCESS);
           <span class="co">// Here, we run code that requires the message to have been</span>
           <span class="co">// successfully sent.</span>
        }
        <span class="kw">if</span>(rank == <span class="dv">1</span>) {
            <span class="dt">char</span> buffer[<span class="dv">256</span>];
            <span class="dt">int</span> <span class="dt">const</span> error = MPI_Recv(
              buffer, <span class="dv">256</span>, MPI_CHAR, <span class="dv">0</span>, <span class="dv">42</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            REQUIRE(error ==  MPI_SUCCESS);
            CHECK(std::string(buffer) == peace);
        }</code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> MPI_Isend(<span class="dt">const</span> <span class="dt">void</span> *buf, <span class="dt">int</span> count, MPI_Datatype datatype, <span class="dt">int</span> dest, <span class="dt">int</span> tag,
              MPI_Comm comm, MPI_Request *request)</code></pre>
</section><section id="pass-the-parcel-sendrecv" class="slide level3">
<h1>Pass the parcel: SendRecv</h1>
<p>Consider a group of N processes in a ring: each has a value, and wants to &quot;pass the parcel&quot; to the left. How would you achieve this with SSend and Receive?</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
    <span class="dt">int</span> message = rank*rank;
    <span class="dt">int</span> received = -<span class="dv">7</span>;

    <span class="co">// Define the ring</span>
    <span class="dt">int</span> left = rank<span class="dv">-1</span>;
    <span class="dt">int</span> right = rank<span class="dv">+1</span>;
    <span class="kw">if</span> (rank==<span class="dv">0</span>) {
      left = size<span class="dv">-1</span>;
    }
    <span class="kw">if</span> (rank == size<span class="dv">-1</span>){
      right = <span class="dv">0</span>;
    }</code></pre>
<p>With synchronous calls each process can only either be sending or receiving. So the even processes need to send, while the odd ones receive, then vice-versa. This is clearly inefficient.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
      <span class="kw">if</span> (rank%<span class="dv">2</span> == <span class="dv">0</span>) {
        <span class="dt">int</span> error = MPI_Ssend(
          &amp;message, <span class="dv">1</span>, MPI_INT, left, rank, MPI_COMM_WORLD);

        error = MPI_Recv(
          &amp;received, <span class="dv">1</span>, MPI_INT, right, right, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
      }
      <span class="kw">if</span> (rank%<span class="dv">2</span> == <span class="dv">1</span>) {

        <span class="dt">int</span> error = MPI_Recv(
          &amp;received, <span class="dv">1</span>, MPI_INT, right, right, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

        error = MPI_Ssend(
          &amp;message, <span class="dv">1</span>, MPI_INT, left, rank, MPI_COMM_WORLD);
      }
      REQUIRE( received == right*right );</code></pre>
<p>With ISend/IRecv, this can be achieved in one go: each process posts its send, then posts its receive, then waits for completion.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
      MPI_Request request;
      <span class="co">// Everyone sets up their messages to send</span>
      <span class="dt">int</span> error = MPI_Isend(
        &amp;message, <span class="dv">1</span>, MPI_INT, left, rank, MPI_COMM_WORLD, &amp;request);

      <span class="co">// Recv acts as our sync-barrier</span>
      error = MPI_Recv(
        &amp;received, <span class="dv">1</span>, MPI_INT, right, right, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

      <span class="co">// But let&#39;s check our send completed:</span>
      error = MPI_Wait(&amp;request, MPI_STATUS_IGNORE);
      REQUIRE(error ==  MPI_SUCCESS);

      REQUIRE( received == right*right );</code></pre>
<p>However, this is such a common pattern, that there is a separate MPI call to make this easier:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> MPI_Sendrecv(<span class="dt">void</span> *sendbuf, <span class="dt">int</span> scount, MPI_Datatype stype, <span class="dt">int</span> dest, <span class="dt">int</span> stag,
                 <span class="dt">void</span> *recvbuf, <span class="dt">int</span> rcount, MPI_Datatype rtype, <span class="dt">int</span> source, <span class="dt">int</span> rtag,
                 MPI_Comm comm, MPI_Status *status)</code></pre>
<p>Each argument is duplicated for the send and receive payloads.</p>
<p>Classroom exercise: implement ring-send using Sendrecv.</p>
</section><section id="almost-all-point-to-point" class="slide level3">
<h1>Al(most all) point to point</h1>
<p>Sending messages:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">name</th>
<th style="text-align: left;">Blocking</th>
<th style="text-align: left;">forces synchronisation point</th>
<th style="text-align: left;">Buffer-safe</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MPI_Ssend</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">MPI_Send</td>
<td style="text-align: left;">maybe</td>
<td style="text-align: left;">no</td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MPI_Isend</td>
<td style="text-align: left;">no</td>
<td style="text-align: left;">no</td>
<td style="text-align: left;">no</td>
</tr>
</tbody>
</table>
<p>Receiving messages:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">name</th>
<th style="text-align: left;">blocking</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MPI_Recv</td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">MPI_Irecv</td>
<td style="text-align: left;">no</td>
</tr>
</tbody>
</table>
</section></section>
    </div>
  </div>

  <script src="http://lab.hakim.se/reveal-js/lib/js/head.min.js"></script>
  <script src="http://lab.hakim.se/reveal-js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'night', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'http://lab.hakim.se/reveal-js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'http://lab.hakim.se/reveal-js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'http://lab.hakim.se/reveal-js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
