<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Template Meta-Programming</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; }
code > span.dt { color: #dfdfbf; }
code > span.dv { color: #dcdccc; }
code > span.bn { color: #dca3a3; }
code > span.fl { color: #c0bed1; }
code > span.ch { color: #dca3a3; }
code > span.st { color: #cc9393; }
code > span.co { color: #7f9f7f; }
code > span.ot { color: #efef8f; }
code > span.al { color: #ffcfaf; }
code > span.fu { color: #efef8f; }
code > span.er { color: #c3bf9f; }
    </style>
    <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/theme/night.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//css/ucl_reveal.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//site-styles/reveal.css"/>
  <link rel="stylesheet" media="print" href="http://lab.hakim.se/reveal-js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="http://lab.hakim.se/reveal-js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Template Meta-Programming</h1>
    <h3 class="date"></h3>
</section>

<section><section id="template-meta-programming-tmp" class="titleslide slide level2"><h1>Template Meta-Programming (TMP)</h1></section><section id="what-is-it" class="slide level3">
<h1>What Is It?</h1>
<ul>
<li>See <a href="http://en.wikipedia.org/wiki/Template_metaprogramming">Wikipedia</a>, <a href="http://en.wikibooks.org/wiki/C%2B%2B_Programming/Templates/Template_Meta-Programming">Wikibooks</a>, <a href="http://www.keithschwarz.com/talks/slides/tmp-cs242.pdf">Keith Schwarz</a></li>
<li>C++ Template
<ul>
<li>Type or function, parameterised over, set of types, constants or functions</li>
<li>Instantiated at compile time</li>
</ul></li>
<li>Meta Programme
<ul>
<li>Program that produces or manipulates constructs of target language</li>
<li>Typically, it generates code</li>
</ul></li>
<li>Template Meta-Programme
<ul>
<li>C++ programme, uses Templates, generate C++ code at compile time</li>
</ul></li>
</ul>
</section><section id="tmp-is-turing-complete" class="slide level3">
<h1>TMP is Turing Complete</h1>
<ul>
<li>Given: A <a href="http://en.wikipedia.org/wiki/Turing_machine">Turing Machine</a>
<ul>
<li>Tape, head, states, program, etc.</li>
</ul></li>
<li>A language is &quot;Turing Complete&quot; if it can simulate a Turing Machine
<ul>
<li>e.g. Conditional branching, infinite looping</li>
</ul></li>
<li>Turing's work underpins much of &quot;what can be computed&quot; on a modern computer
<ul>
<li>C, C++ no templates, C++ with templates, C++ TMP</li>
<li>All Turing Complete</li>
</ul></li>
<li>Interesting that compiler can generate such theoretically powerful code.<br /></li>
<li>But when, where, why, how to use TMP?<br /></li>
<li>(side-note: Its not just a C++ pre-processor macro)</li>
</ul>
</section><section id="why-use-it" class="slide level3">
<h1>Why Use It?</h1>
<ul>
<li>Use sparingly as code difficult to follow</li>
<li>Use for
<ul>
<li>Optimisations</li>
<li>Represent Behaviour as a Type</li>
<li>Traits classes</li>
</ul></li>
<li>But when you see it, you need to understand it!</li>
</ul>
</section><section id="factorial-example" class="slide level3">
<h1>Factorial Example</h1>
<p>See <a href="http://en.wikipedia.org/wiki/Template_metaprogramming">Wikipedia Factorial Example</a></p>
<ul>
<li>This:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">template</span> &lt;<span class="dt">int</span> n&gt;
<span class="kw">struct</span> factorial {
    <span class="kw">enum</span> { value = n * factorial&lt;n - <span class="dv">1</span>&gt;::value };
};

<span class="kw">template</span> &lt;&gt;
<span class="kw">struct</span> factorial&lt;<span class="dv">0</span>&gt; {
    <span class="kw">enum</span> { value = <span class="dv">1</span> };
};

<span class="dt">int</span> main () {
  std::cout &lt;&lt; factorial&lt;<span class="dv">0</span>&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; factorial&lt;<span class="dv">8</span>&gt;::value &lt;&lt; std::endl;
}</code></pre>
<ul>
<li>Produces:</li>
</ul>
<pre><code>1
40320
</code></pre>
</section><section id="factorial-notes" class="slide level3">
<h1>Factorial Notes:</h1>
<ul>
<li>Compiler must know values at compile time
<ul>
<li>i.e. constant literal or constant expression</li>
<li>See also <a href="http://en.wikipedia.org/wiki/C%2B%2B11#constexpr_.E2.80.93_Generalized_constant_expressions">constexpr</a></li>
</ul></li>
<li>Generates/Instantiates all functions recursively</li>
<li>Factorial 16 = 2004189184</li>
<li>Factorial 17 overflows</li>
<li>This simple example to illustrate &quot;computation&quot;</li>
<li>But when is TMP actually useful?</li>
<li>Notice that parameter was an integer value ... not just &quot;int&quot; type</li>
</ul>
</section><section id="loop-example" class="slide level3">
<h1>Loop Example</h1>
<ul>
<li>This:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T Sum(<span class="dt">const</span> std::vector&lt;T&gt;&amp; data)
{
  T total = <span class="dv">0</span>;
  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; data.size(); i++)
  {
    total += data[i];
  }
  <span class="kw">return</span> total;
}

<span class="dt">int</span> main () {
  size_t numberOfInts = <span class="dv">3</span>;
  size_t numberOfLoops = <span class="dv">1000000000</span>;
  vector&lt;<span class="dt">int</span>&gt; a(numberOfInts);
  <span class="dt">int</span> total = <span class="dv">0</span>;

  std::cout &lt;&lt; <span class="st">&quot;Started&quot;</span> &lt;&lt; std::endl;
  <span class="kw">for</span> (size_t j = <span class="dv">0</span>; j &lt; numberOfLoops; j++)
  {
    <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; numberOfInts; i++)
    {
      total = Sum(a);
    }
  }
  std::cout &lt;&lt; <span class="st">&quot;Finished:&quot;</span> &lt;&lt; total &lt;&lt; std::endl;
}</code></pre>
<ul>
<li>Time: numberOfInts=3 took 40 seconds</li>
</ul>
</section><section id="loop-unrolled" class="slide level3">
<h1>Loop Unrolled</h1>
<ul>
<li>This:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">int</span> length&gt;
<span class="kw">class</span> FixedVector {
   T data[length];
  <span class="kw">public</span>:
    FixedVector()
    {
      <span class="co">// Initialise</span>
      <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; length; i++)
      {
        data[i] = <span class="dv">0</span>;
      }
    }
    T Sum()
    {
      T sum = <span class="dv">0</span>;
      <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; length; i++)
      {
        sum += data[i];
      }
      <span class="kw">return</span> sum;
    }
};

<span class="dt">int</span> main () {
  <span class="dt">const</span> size_t numberOfInts = <span class="dv">3</span>;
  <span class="dt">const</span> size_t numberOfLoops = <span class="dv">1000000000</span>;
  FixedVector&lt;<span class="dt">int</span>, numberOfInts&gt; a;
  <span class="dt">int</span> total = <span class="dv">0</span>;

  std::cout &lt;&lt; <span class="st">&quot;Started&quot;</span> &lt;&lt; std::endl;
  <span class="kw">for</span> (size_t j = <span class="dv">0</span>; j &lt; numberOfLoops; j++)
  {
    <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; numberOfInts; i++)
    {
      total = a.Sum();
    }
  }
  std::cout &lt;&lt; <span class="st">&quot;Finished:&quot;</span> &lt;&lt; total &lt;&lt; std::endl;
}</code></pre>
<ul>
<li>Time: numberOfInts=3 took 32 seconds when switch to fixed vector, and 23 when a raw array.</li>
</ul>
</section><section id="policy-checking" class="slide level3">
<h1>Policy Checking</h1>
<ul>
<li>Templates parameterised by type not by behaviour</li>
<li>But you can make a class to represent the behaviour</li>
<li>See <a href="http://www.keithschwarz.com/talks/slides/tmp-cs242.pdf">Keith Schwarz</a> for longer example.</li>
</ul>
</section><section id="simple-policy-checking-example" class="slide level3">
<h1>Simple Policy Checking Example</h1>
<ul>
<li>This:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;stdexcept&gt;</span>

<span class="kw">class</span> NoRangeCheckingPolicy {
  <span class="kw">public</span>:
    <span class="dt">static</span> <span class="dt">void</span> CheckRange(size_t pos, size_t n) { <span class="kw">return</span>; } <span class="co">// no checking</span>
};

<span class="kw">class</span> ThrowErrorRangeCheckingPolicy {
  <span class="kw">public</span>:
    <span class="dt">static</span> <span class="dt">void</span> CheckRange(size_t pos, size_t n)
    {
      <span class="kw">if</span> (pos &gt;= n) { <span class="kw">throw</span> std::runtime_error(<span class="st">&quot;Out of range!&quot;</span>); }
    }
};

<span class="kw">template</span> &lt; <span class="kw">typename</span> T
         , <span class="kw">typename</span> RangeCheckingPolicy = NoRangeCheckingPolicy
         &gt;
<span class="kw">class</span> Vector
 : <span class="kw">public</span> RangeCheckingPolicy
{

  <span class="kw">private</span>:
    std::vector&lt;T&gt; data;
  <span class="kw">public</span>:
    <span class="co">// other methods etc.</span>
    <span class="dt">const</span> T&amp; <span class="kw">operator</span>[] (size_t pos) <span class="dt">const</span>
    {
      RangeCheckingPolicy::CheckRange(pos, data.size());
      <span class="kw">return</span> data[pos];
    }
};

<span class="dt">int</span> main () {
  Vector&lt;<span class="dt">int</span>, ThrowErrorRangeCheckingPolicy&gt; a;
  <span class="co">// a.push_back(1); or similar</span>
  <span class="co">// a.push_back(2); or similar</span>
  <span class="kw">try</span> {
    std::cout &lt;&lt; a[<span class="dv">3</span>] &lt;&lt; std::endl;
  } <span class="kw">catch</span> (<span class="dt">const</span> std::runtime_error&amp; e)
  {
    std::cerr &lt;&lt; e.what();
  }
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<ul>
<li>Produces:</li>
</ul>
<pre><code></code></pre>
</section><section id="summary-of-policy-checking-example" class="slide level3">
<h1>Summary of Policy Checking Example</h1>
<ul>
<li>Define interface for behaviour</li>
<li>Parameterize over all behaviours</li>
<li>Use multiple-inheritance to import policies</li>
<li>e.g. logging / asserts</li>
</ul>
</section><section id="traits" class="slide level3">
<h1>Traits</h1>
<ul>
<li>From C++ standard 17.1.18
<ul>
<li>&quot;a class that encapsulates a set of types and functions necessary for template classes and template functions to manipulate objects of types for which they are instantiated.&quot;</li>
</ul></li>
<li>Basically: Traits represent details about a type</li>
<li>You may be using them already!</li>
<li>Start with a simple example</li>
</ul>
</section><section id="simple-traits-example" class="slide level3">
<h1>Simple Traits Example</h1>
<ul>
<li>This:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">struct</span> is_void {
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">bool</span> value = <span class="kw">false</span>;
};

<span class="kw">template</span> &lt;&gt;
<span class="kw">struct</span> is_void&lt;<span class="dt">void</span>&gt; {
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">bool</span> value = <span class="kw">true</span>;
};

<span class="dt">int</span> main () {
  std::cout &lt;&lt; <span class="st">&quot;is_void(void)=&quot;</span> &lt;&lt; is_void&lt;<span class="dt">void</span>&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="st">&quot;is_void(int)=&quot;</span> &lt;&lt; is_void&lt;<span class="dt">int</span>&gt;::value &lt;&lt; std::endl;
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<ul>
<li>Produces:</li>
</ul>
<pre><code>is_void(void)=1
is_void(int)=0
</code></pre>
</section><section id="traits-principles" class="slide level3">
<h1>Traits Principles</h1>
<ul>
<li>Small, simple, normally public, eg. struct</li>
<li>else/if
<ul>
<li>Else template</li>
<li>partial specialisations</li>
<li>full specialisations</li>
</ul></li>
<li>Probably using them already
<ul>
<li><code>std::numeric_limits&lt;double&gt;::max()</code></li>
<li>ITK has similar <code>itk::NumericTrait&lt;PixelType&gt;</code></li>
</ul></li>
<li>Applies to primatives as well as types</li>
</ul>
</section><section id="traits-examples" class="slide level3">
<h1>Traits Examples</h1>
<ul>
<li><a href="http://blog.aaronballman.com/2011/11/a-simple-introduction-to-type-traits">Simple Tutorial from Aaron Ballman</a></li>
<li><a href="http://www.boost.org/doc/libs/?view=category_Metaprogramming">Boost meta-programming support</a></li>
<li><a href="http://www.boost.org/doc/libs/1_57_0/libs/type_traits/doc/html/boost_typetraits/background.html">Boost type_traits tutorial</a></li>
<li><a href="http://www.cplusplus.com/reference/type_traits">C++11 has many traits</a></li>
</ul>
</section><section id="wait-inheritance-vs-traits" class="slide level3">
<h1>Wait, Inheritance Vs Traits?</h1>
<ul>
<li>We said inheritance is often overused in OO</li>
<li>We say that too frequent if/switch statements based on type are bad in OO</li>
<li>C++11 providing many <a href="http://www.cplusplus.com/reference/type_traits">is_X type traits</a> returning bool, leading to if/else</li>
<li>So, when to use it?</li>
</ul>
</section><section id="when-to-use-traits" class="slide level3">
<h1>When to use Traits</h1>
<ul>
<li>Some advice
<ul>
<li>Sparingly</li>
<li>To add information to templated types</li>
<li>Get algorithm to work for 1 data type</li>
<li>If you extend to multiple data types and consider templates
<ul>
<li>When you need type specific behaviour
<ul>
<li>traits probably better than template specialisation</li>
<li>traits better than inheritance based template hierarchies</li>
</ul></li>
</ul></li>
</ul></li>
<li>Remember
<ul>
<li>Scientist = few use-cases</li>
<li>Library designer = coding for the unknown, and potentially limitless use-cases
<ul>
<li>More likely of interest to library designers</li>
</ul></li>
</ul></li>
</ul>
</section><section id="tmp-use-in-medical-imaging---1" class="slide level3">
<h1>TMP Use in Medical Imaging - 1</h1>
<p>Declare an <a href="http://www.itk.org">ITK</a> image</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">template</span>&lt; <span class="kw">typename</span> TPixel, <span class="dt">unsigned</span> <span class="dt">int</span> VImageDimension = <span class="dv">2</span> &gt;
<span class="kw">class</span> Image:<span class="kw">public</span> ImageBase&lt; VImageDimension &gt;
{
<span class="kw">public</span>:
<span class="co">// etc</span></code></pre>
<ul>
<li>TPixel, <code>int</code>, <code>float</code> etc.</li>
<li>VImageDimension = number of dimensions</li>
</ul>
</section><section id="tmp-use-in-medical-imaging---2" class="slide level3">
<h1>TMP Use in Medical Imaging - 2</h1>
<p>But what type is origin/spacing/dimensions?</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="dt">unsigned</span> <span class="dt">int</span> VImageDimension = <span class="dv">2</span> &gt;
<span class="kw">class</span> ImageBase:<span class="kw">public</span> DataObject
{
  <span class="kw">typedef</span> SpacePrecisionType                          SpacingValueType;
  <span class="kw">typedef</span> Vector&lt; SpacingValueType, VImageDimension &gt; SpacingType;</code></pre>
</section><section id="tmp-use-in-medical-imaging---3" class="slide level3">
<h1>TMP Use in Medical Imaging - 3</h1>
<p>So now look at <code>Vector</code></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="kw">typename</span> T, <span class="dt">unsigned</span> <span class="dt">int</span> NVectorDimension = <span class="dv">3</span> &gt;
<span class="kw">class</span> Vector:<span class="kw">public</span> FixedArray&lt; T, NVectorDimension &gt;
{
<span class="kw">public</span>:</code></pre>
</section><section id="tmp-use-in-medical-imaging---4" class="slide level3">
<h1>TMP Use in Medical Imaging - 4</h1>
<p>Now we can see how fixed length arrays are used</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="kw">typename</span> T, <span class="dt">unsigned</span> <span class="dt">int</span> TVectorDimension &gt;
<span class="dt">const</span> <span class="kw">typename</span> Vector&lt; T, TVectorDimension &gt;::Self &amp;
Vector&lt; T, TVectorDimension &gt;
::<span class="kw">operator</span>+=(<span class="dt">const</span> Self &amp; vec)
{
  <span class="kw">for</span> ( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; TVectorDimension; i++ )
    {
    ( *<span class="kw">this</span> )[i] += vec[i];
    }
  <span class="kw">return</span> *<span class="kw">this</span>;
}</code></pre>
<p>which may be unrolled by compiler.</p>
</section><section id="tmp-use-in-medical-imaging---5" class="slide level3">
<h1>TMP Use in Medical Imaging - 5</h1>
<ul>
<li><a href="http://www.itk.org">ITK</a>
<ul>
<li>uses <a href="http://www.itk.org/Doxygen/html/classitk_1_1NumericTraits.html"><code>itk::NumericTraits&lt;&gt;</code></a> adding mathematical operators like multiplicative identity, additive identity</li>
<li>uses traits to describe features of meshes, <code>like numeric_limits</code>, but more generalised</li>
</ul></li>
<li><a href="http://www.mitk.org">MITK</a> (requires coffee and a quiet room)
<ul>
<li>uses <a href="http://docs.mitk.org/2014.03/mitkPixelTypeList_8h.html">mitkPixelTypeList.h</a> for multi-plexing across templated image to non-templated image type</li>
<li>uses <a href="http://docs.mitk.org/nightly-qt4/mitkGetClassHierarchy_8h.html">mitkGetClassHierarchy.h</a> to extract a list of class names in the inheritance hierarchy</li>
</ul></li>
<li><a href="http://link.springer.com/chapter/10.1007%2F978-3-319-08554-8_2">TMP in B-spline based registration</a>:</li>
</ul>
</section><section id="further-reading-for-traits" class="slide level3">
<h1>Further Reading For Traits</h1>
<ul>
<li><a href="http://www.keithschwarz.com/talks/slides/tmp-cs242.pdf">Keith Schwarz</a></li>
<li><a href="http://www.cantrip.org/traits.html">Nathan Meyers</a></li>
<li><a href="http://www.cs.rpi.edu/~musser/design/blitz/traits.html">Todd Veldhuizen, traits scientific computing</a></li>
<li><a href="http://accu.org/index.php/journals/442">Thaddaaeus Frogley, ACCU, traits tutorial</a></li>
<li><a href="http://blog.aaronballman.com/2011/11/a-simple-introduction-to-type-traits">Aaron Ballman</a></li>
<li><a href="http://erdani.com/publications/traits.html">Andrei Alexandrescu</a></li>
<li><a href="http://erdani.com/publications/traits_on_steroids.html">Andrei Alexandrescu traits with state</a></li>
<li><a href="http://www.boost.org/doc/libs/?view=category_Metaprogramming">Boost meta-mrogramming support</a></li>
<li><a href="http://www.boost.org/doc/libs/1_57_0/libs/type_traits/doc/html/boost_typetraits/background.html">Boost type_traits tutorial</a></li>
<li><a href="http://www.cplusplus.com/reference/type_traits">C++11 has many traits</a></li>
</ul>
</section><section id="further-reading-in-general" class="slide level3">
<h1>Further Reading In General</h1>
<ul>
<li><a href="http://www.amazon.co.uk/Modern-Design-Generic-Programming-Patterns/dp/0201704315/ref=sr_1_1?ie=UTF8&amp;qid=1421739179&amp;sr=8-1&amp;keywords=andrei+alexandrescu">Andrei Alexandrescu's Book</a></li>
<li><a href="http://herbsutter.com">Herb Sutter</a>'s <a href="http://www.gotw.ca/gotw">Guru of The Week</a>, especially <a href="http://www.gotw.ca/gotw/071.htm">71</a> and <a href="http://www.gotw.ca/publications/mxc++-item-4.htm">this</a> article</li>
<li>And of course, keep reading <a href="http://www.aristeia.com/books.html">Meyers</a></li>
</ul>
</section><section id="summary" class="slide level3">
<h1>Summary</h1>
<ul>
<li>Learnt
<ul>
<li>Notation for template function/class/meta-programming</li>
<li>Uses and limitations of template function/class</li>
<li>Template Meta-Programming
<ul>
<li>Optimisation, loop unrolling</li>
<li>Policy classes</li>
<li>Traits</li>
</ul></li>
</ul></li>
</ul>
</section></section>
    </div>
  </div>

  <script src="http://lab.hakim.se/reveal-js/lib/js/head.min.js"></script>
  <script src="http://lab.hakim.se/reveal-js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'night', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'http://lab.hakim.se/reveal-js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'http://lab.hakim.se/reveal-js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'http://lab.hakim.se/reveal-js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
