<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Exercise</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; }
code > span.dt { color: #dfdfbf; }
code > span.dv { color: #dcdccc; }
code > span.bn { color: #dca3a3; }
code > span.fl { color: #c0bed1; }
code > span.ch { color: #dca3a3; }
code > span.st { color: #cc9393; }
code > span.co { color: #7f9f7f; }
code > span.ot { color: #efef8f; }
code > span.al { color: #ffcfaf; }
code > span.fu { color: #efef8f; }
code > span.er { color: #c3bf9f; }
    </style>
    <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/theme/night.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//css/ucl_reveal.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//site-styles/reveal.css"/>
  <link rel="stylesheet" media="print" href="http://lab.hakim.se/reveal-js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="http://lab.hakim.se/reveal-js/lib/js/html5shiv.js"></script>
  <![endif]-->
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Exercise</h1>
    <h3 class="date"></h3>
</section>

<section><section id="wavelet-decomposition" class="titleslide slide level2"><h1>Wavelet decomposition</h1></section><section id="wavelet-transforms" class="slide level3">
<h1> Wavelet transforms</h1>
<ul>
<li><p><a href="http://en.wikipedia.org/wiki/Wavelet_transform">Walevet transforms</a> decompose a signal into details of increasingly large scales</p></li>
<li>Given a signal <span class="math">\(s[j]\)</span>, with <span class="math">\(j \in [1, N]\)</span>, we want to split
<ul>
<li>an approximation <span class="math">\(A_s[i]\)</span> with <span class="math">\(i \in [1, N/2]\)</span></li>
<li>the details <span class="math">\(D_s[i]\)</span> with <span class="math">\(i \in [1, N/2]\)</span></li>
</ul></li>
<li><p>Repeat the process on the approximaton</p></li>
</ul>
</section><section id="pseudo-code" class="slide level3">
<h1> Pseudo-code</h1>
<ul>
<li>loop over levels in <span class="math">\([0, L^\textrm{max}]\)</span></li>
</ul>
<p>For simplicity, the signal is periodic: <span class="math">\(s[j] = s[j + N]\)</span>.</p>
<ul>
<li>set <span class="math">\(N&#39; = N\)</span> if <span class="math">\(N\)</span> is even, <span class="math">\(N&#39;=N+1\)</span> otherwise</li>
<li>with <span class="math">\(j \in [0, N&#39; - 1], i \in [0, n - 1]\)</span></li>
<li>set <span class="math">\(D^s[j] = \sum_{i=0}^{n - 1} s[2*j + i] h[i]\)</span></li>
<li>set <span class="math">\(A^s[j] = \sum_{i=0}^{n - 1} s[2*j + i] l[i]\)</span></li>
<li>set <span class="math">\(s = A^s\)</span></li>
</ul>
</section><section id="instructions" class="slide level3">
<h1> Instructions</h1>
<p>Given a header and the unit-tests:</p>
<ol type="1">
<li>reconstruct the serial version using the jigsaw implementation file</li>
<li>Parallelize with openmp</li>
</ol>
<p>How many parallelization schemes did you come up with?</p>
<p>If you are not having enough fun, figure out the inverse operation. Wavelets transforms are bijective.</p>
</section><section id="header" class="slide level3">
<h1> Header</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef CPP_COURSE_WAVELETS_H</span>

<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">namespace</span> wavelets {

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Underlying type of all real numbers in the wavelets</span>
<span class="co">//! </span><span class="kw">\details</span><span class="co"> Defining a &quot;type hierarchy&quot; makes it easy to modify all the basic</span>
<span class="co">//! types underlying a coding project</span>
<span class="kw">typedef</span> <span class="dt">double</span> Scalar;

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Represents 1-D signal of any size</span>
<span class="kw">typedef</span> std::vector&lt;Scalar&gt; Signal;

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> High and low-pass filter data</span>
<span class="co">//! </span><span class="kw">\details</span>
<span class="co">//! Note</span>
<span class="co">//! ----</span>
<span class="co">//!</span>
<span class="co">//! This structure declares it&#39;s attribute public. And later we declare global</span>
<span class="co">//! variables as instances of this type. Both of these aspects are frowned</span>
<span class="co">//! upon, *except* in this one case. The wavelet filters are constants for a</span>
<span class="co">//! given Daubechy wavelet. For constants of nature and constants of math,</span>
<span class="co">//! whether scalar or vectorial (and small), it&#39;s okay to use global variable</span>
<span class="co">//! and public attributes. Otherwise, beware!</span>
<span class="co">//!</span>
<span class="co">//! Premature Optimization?</span>
<span class="co">//! -----------------------</span>
<span class="co">//!</span>
<span class="co">//! We could have `std::array</span><span class="kw">&lt;Scalar</span><span class="ot">, N</span><span class="kw">&gt;</span><span class="co"> high_pass` and the same for</span>
<span class="co">//! `low_pass`. However, `N`, the number of coeffients, depends on the actual</span>
<span class="co">//! wavelet. And in `std::array</span><span class="kw">&lt;Scalar</span><span class="ot">, N</span><span class="kw">&gt;</span><span class="co">`, `N` needs to be known at compile</span>
<span class="co">//! time. We could make this change and the compiler might be able to make use</span>
<span class="co">//! of this extra information to produce faster code. However, it would mean</span>
<span class="co">//! that `DaubechyData` needs to be declared as `template</span><span class="kw">&lt;int</span><span class="ot"> N</span><span class="kw">&gt;</span><span class="co"> struct</span>
<span class="co">//! DaubechyData`, and all the functions taking `DaubechyData</span><span class="kw">&lt;N&gt;</span><span class="co">` as input</span>
<span class="co">//! would also need to be templates.</span>
<span class="co">//!</span>
<span class="co">//! Templating is cool, fun, but viral. So we might as well use the simpler</span>
<span class="co">//! implementation and wait for benchmarks and profiling results to tell us</span>
<span class="co">//! whether we really need the extra complexity.</span>
<span class="kw">struct</span> DaubechyData {
  std::vector&lt;Scalar&gt; low_pass;
  std::vector&lt;Scalar&gt; high_pass;
};

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Data for the Daubechy wavelets of type 1</span>
<span class="co">//! </span><span class="kw">\details</span><span class="co"> This data does not change from code to code. In fact, I got them</span>
<span class="co">//! from wikipedia. Constants of nature and constants of math are the only</span>
<span class="co">//! variable that should be declared global (and `const`).</span>
<span class="kw">extern</span> DaubechyData <span class="dt">const</span> daubechy1;
<span class="co">//! Data for the Daubechy wavelets of type 2</span>
<span class="kw">extern</span> DaubechyData <span class="dt">const</span> daubechy2;

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Applies a filter starting from a given location of the signal</span>
<span class="co">//! </span><span class="kw">\details</span><span class="co"> The signal is defined by the range `start`, and `end`. `location`</span>
<span class="co">//! must be a position inside that range. The filter is applied starting from</span>
<span class="co">//! that location of the signal.</span>
Scalar apply_cyclical_filter(Signal::const_iterator <span class="dt">const</span> &amp;start, Signal::const_iterator location,
                             Signal::const_iterator <span class="dt">const</span> &amp;end, Signal <span class="dt">const</span> &amp;filter);

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Applies a filter starting from a given location of the signal</span>
<span class="co">//! </span><span class="kw">\details</span><span class="co"> Accumulates the result of `signal[location + i] * filter[i]` for i</span>
<span class="co">//! in `[0, filter.size()[`. If `location + i` goes out of range, then it</span>
<span class="co">//! cycles back to the begining of the signal. In practice, this means the</span>
<span class="co">//! signal is periodic.</span>
<span class="co">//!</span>
<span class="co">//! This is a thin wrapper around the function that does the work. Its purpose</span>
<span class="co">//! is to provide a user-friendly interface for end users and for testing.</span>
Scalar
apply_cyclical_filter(Signal <span class="dt">const</span> &amp;signal, Signal::size_type location, Signal <span class="dt">const</span> &amp;filter);

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Applies the wavelet transform once to the signal</span>
<span class="co">//! </span><span class="kw">\details</span><span class="co"> The output iterator should point to a valid range of the same size</span>
<span class="co">//! as the input signal *if the size of the signal is even*, and one larger than the signal</span>
<span class="co">//! *if the size of the signal is odd*. The result is undefined when the signal</span>
<span class="co">//! and output arrays overlap.</span>
<span class="dt">void</span> single_direct_transform(Signal::const_iterator <span class="dt">const</span> &amp;start, Signal::const_iterator <span class="dt">const</span> &amp;end,
                             Signal::iterator <span class="dt">const</span> &amp;out, DaubechyData <span class="dt">const</span> &amp;wavelet);

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Applies high and low pass once to the signal range</span>
<span class="co">//! </span><span class="kw">\details</span><span class="co"> This wrapper is also to make testing somewhat simpler.</span>
Signal single_direct_transform(Signal <span class="dt">const</span> &amp;signal, DaubechyData <span class="dt">const</span> &amp;wavelet);

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Applies the wavelet transform `levels` time to the signal</span>
<span class="co">//! </span><span class="kw">\details</span><span class="co"> The number of coefficients is given by the function</span>
<span class="co">//! `number_of_coefficients`.</span>
<span class="dt">void</span> direct_transform(Signal::const_iterator start, Signal::const_iterator end,
                      Signal::iterator out, DaubechyData <span class="dt">const</span> &amp;wavelet, <span class="dt">unsigned</span> <span class="dt">int</span> levels = <span class="dv">1</span>);

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Figures out number of coeffs</span>
<span class="dt">unsigned</span> <span class="dt">int</span> number_of_coefficients(<span class="dt">unsigned</span> <span class="dt">int</span> signal_size, <span class="dt">unsigned</span> <span class="dt">int</span> levels);

<span class="co">//! </span><span class="kw">\brief</span><span class="co"> Transforms the input signal</span>
Signal direct_transform(Signal <span class="dt">const</span> &amp;signal, DaubechyData <span class="dt">const</span> &amp;wavelet, <span class="dt">unsigned</span> <span class="dt">int</span> levels = <span class="dv">1</span>);
}
<span class="ot">#endif</span></code></pre>
</section><section id="tests" class="slide level3">
<h1> Tests</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define CATCH_CONFIG_MAIN </span><span class="co">// This tells Catch to provide a main() - only do this in one cpp file</span>
<span class="ot">#include &quot;wavelets.h&quot;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;catch/catch.hpp&gt;</span>
<span class="ot">#ifdef _OPENMP</span>
<span class="ot">#include &lt;omp.h&gt;</span>
<span class="ot">#endif</span>

TEST_CASE(<span class="st">&quot;Application of Cyclical Filters&quot;</span>)
{
  wavelets::Signal <span class="dt">const</span> signal{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span> };
  wavelets::Signal <span class="dt">const</span> filter{ <span class="dv">3</span>, -<span class="dv">3</span> };

  SECTION(<span class="st">&quot;No cyclical overlap problem&quot;</span>)
  {
    CHECK(wavelets::apply_cyclical_filter(signal, <span class="dv">0</span>, filter) == Approx(-<span class="dv">3</span>));
    CHECK(wavelets::apply_cyclical_filter(signal, <span class="dv">1</span>, filter) == Approx(-<span class="dv">3</span>));
    CHECK(wavelets::apply_cyclical_filter(signal, <span class="dv">2</span>, filter) == Approx(-<span class="dv">6</span>));
  }
  SECTION(<span class="st">&quot;Filter reaches exactly end of signal&quot;</span>)
  {
    CHECK(wavelets::apply_cyclical_filter(signal, <span class="dv">4</span>, filter) == Approx(-<span class="dv">3</span>));
  }
  SECTION(<span class="st">&quot;Filter reaches past end of signal&quot;</span>)
  {
    CHECK(wavelets::apply_cyclical_filter(signal, <span class="dv">5</span>, filter) == Approx(<span class="dv">15</span>));
  }

  SECTION(<span class="st">&quot;Empty filter&quot;</span>)
  {
    CHECK(wavelets::apply_cyclical_filter({ <span class="dv">5</span>, <span class="dv">2</span> }, <span class="dv">0</span>, {}) == Approx(<span class="dv">0</span>));
  }
  SECTION(<span class="st">&quot;Empty signal&quot;</span>)
  {
    CHECK(wavelets::apply_cyclical_filter({}, <span class="dv">0</span>, { <span class="dv">1</span>, <span class="dv">2</span> }) == Approx(<span class="dv">0</span>));
  }
  SECTION(<span class="st">&quot;Empty signal and filter&quot;</span>)
  {
    CHECK(wavelets::apply_cyclical_filter({}, <span class="dv">0</span>, {}) == Approx(<span class="dv">0</span>));
  }
  SECTION(<span class="st">&quot;Filter much much bigger than signal&quot;</span>)
  {
    CHECK(wavelets::apply_cyclical_filter({ <span class="dv">1</span>, <span class="dv">2</span> }, <span class="dv">0</span>, { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span> }) == Approx(<span class="dv">21</span>));
  }
}

TEST_CASE(<span class="st">&quot;Single pass wavelet transform&quot;</span>)
{
  <span class="co">// Use unnormalized haar wavelets, because simple</span>
  <span class="co">// Normalize by multiplyint the coeffs by std::sqrt(2)</span>
  wavelets::DaubechyData <span class="dt">const</span> haar{ { <span class="dv">1</span>, <span class="dv">1</span> }, { <span class="dv">1</span>, -<span class="dv">1</span> } };
  SECTION(<span class="st">&quot;Haar&quot;</span>)
  {
    <span class="co">// Odd number of elements to test periodicity</span>
    <span class="dt">auto</span> <span class="dt">const</span> actual = single_direct_transform({ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">8</span> }, haar);
    <span class="co">//                                 high pass             low pass</span>
    <span class="co">//                                     =                     =</span>
    <span class="co">//                                  details            approximation</span>
    wavelets::Signal <span class="dt">const</span> expected{ -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">1</span>, <span class="dv">7</span>, <span class="co">/*   */</span> <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">11</span>, <span class="dv">9</span> };
    REQUIRE(actual.size() == expected.size());
    CHECK(std::equal(actual.begin(), actual.end(), expected.begin()));
  }

  SECTION(<span class="st">&quot;Empty signal&quot;</span>)
  {
    CHECK(wavelets::single_direct_transform({}, haar).size() == <span class="dv">0</span>);
  }
}

TEST_CASE(<span class="st">&quot;Multi-pass wavelet transform&quot;</span>)
{
  wavelets::DaubechyData <span class="dt">const</span> haar{ { <span class="dv">1</span>, <span class="dv">1</span> }, { <span class="dv">1</span>, -<span class="dv">1</span> } };
  SECTION(<span class="st">&quot;Empty signal&quot;</span>)
  {
    CHECK(wavelets::direct_transform({}, haar, <span class="dv">2</span>).size() == <span class="dv">0</span>);
  }
  SECTION(<span class="st">&quot;Level 0 is a copy&quot;</span>)
  {
    wavelets::Signal <span class="dt">const</span> signal{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span> };
    <span class="dt">auto</span> <span class="dt">const</span> actual = wavelets::direct_transform(signal, haar, <span class="dv">0</span>);
    REQUIRE(actual.size() == signal.size());
    CHECK(std::equal(actual.begin(), actual.end(), signal.begin()));
  }
  SECTION(<span class="st">&quot;Haar&quot;</span>)
  {
    wavelets::Signal <span class="dt">const</span> signal{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">8</span> };
    std::vector&lt;wavelets::Signal&gt; <span class="dt">const</span> expecteds{
      signal,                                     <span class="co">// level 0</span>
      { -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">11</span>, <span class="dv">9</span> },             <span class="co">// level 1</span>
      { -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">1</span>, <span class="dv">7</span>, -<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">11</span>, <span class="dv">20</span> },           <span class="co">// level 2</span>
      { -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">1</span>, <span class="dv">7</span>, -<span class="dv">5</span>, <span class="dv">2</span>, -<span class="dv">9</span>, <span class="dv">31</span> },           <span class="co">// level 3</span>
      { -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">1</span>, <span class="dv">7</span>, -<span class="dv">5</span>, <span class="dv">2</span>, -<span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">62</span> },        <span class="co">// level 4</span>
      { -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">1</span>, <span class="dv">7</span>, -<span class="dv">5</span>, <span class="dv">2</span>, -<span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">124</span> },    <span class="co">// level 5</span>
      { -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">1</span>, <span class="dv">7</span>, -<span class="dv">5</span>, <span class="dv">2</span>, -<span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">248</span> }, <span class="co">// level 6</span>
    };
    <span class="kw">for</span> (<span class="kw">decltype</span>(expecteds.size()) levels(<span class="dv">0</span>); levels &lt; expecteds.size(); ++levels) {
      <span class="dt">auto</span> <span class="dt">const</span> actual = direct_transform(signal, haar, levels);
      REQUIRE(actual.size() == expecteds[levels].size());
      CHECK(std::equal(actual.begin(), actual.end(), expecteds[levels].begin()));
    }
  }
}

<span class="ot">#ifdef _OPENMP</span>
<span class="co">// Catch offers to print out the duration of a test, so we can use it as a</span>
<span class="co">// make-do benchmarking framework</span>
<span class="co">// Run the executable with --duration yes</span>
TEST_CASE(<span class="st">&quot;OpenMP&quot;</span>)
{
  wavelets::Signal input(<span class="dv">1000000</span>);
  wavelets::Signal output(<span class="dv">1000000</span>);
  std::generate(input.begin(), input.end(), std::rand);
  std::fill(output.begin(), output.end(), <span class="dv">0</span>);
  SECTION(<span class="st">&quot;Serial&quot;</span>)
  {
    <span class="dt">auto</span> <span class="dt">const</span> nthreads = omp_get_max_threads();
    omp_set_num_threads(<span class="dv">1</span>);
    <span class="kw">for</span> (<span class="dt">int</span> i(<span class="dv">0</span>); i &lt; <span class="dv">1000</span>; ++i)
      wavelets::direct_transform(
          input.begin(), input.end(), output.begin(), wavelets::daubechy2, <span class="dv">8</span>);
    omp_set_num_threads(nthreads);
  }
  SECTION(<span class="st">&quot;Parallel&quot;</span>)
  {
    <span class="kw">for</span> (<span class="dt">int</span> i(<span class="dv">0</span>); i &lt; <span class="dv">1000</span>; ++i)
      wavelets::direct_transform(
          input.begin(), input.end(), output.begin(), wavelets::daubechy2, <span class="dv">8</span>);
  }
}
<span class="ot">#endif</span></code></pre>
</section><section id="implementation" class="slide level3">
<h1> Implementation</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;wavelets.h&quot;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;numeric&gt;</span>
<span class="ot">#ifdef _OPENMP</span>
<span class="ot">#include &lt;omp.h&gt;</span>
<span class="ot">#endif</span>

<span class="kw">namespace</span> wavelets {

DaubechyData <span class="dt">const</span> daubechy1{
  { <span class="fl">7.071067811865475244008443621048490392848359376884740365883398e-01</span>,
      <span class="fl">7.071067811865475244008443621048490392848359376884740365883398e-01</span> },
  { -<span class="fl">7.071067811865475244008443621048490392848359376884740365883398e-01</span>,
      <span class="fl">7.071067811865475244008443621048490392848359376884740365883398e-01</span> }
};

DaubechyData <span class="dt">const</span> daubechy2{
  { <span class="fl">4.829629131445341433748715998644486838169524195042022752011715e-01</span>,
      <span class="fl">8.365163037378079055752937809168732034593703883484392934953414e-01</span>,
      <span class="fl">2.241438680420133810259727622404003554678835181842717613871683e-01</span>,
      -<span class="fl">1.294095225512603811744494188120241641745344506599652569070016e-01</span> },
  { <span class="fl">1.294095225512603811744494188120241641745344506599652569070016e-01</span>,
      <span class="fl">2.241438680420133810259727622404003554678835181842717613871683e-01</span>,
      -<span class="fl">8.365163037378079055752937809168732034593703883484392934953414e-01</span>,
      <span class="fl">4.829629131445341433748715998644486838169524195042022752011715e-01</span> }
};

Scalar apply_cyclical_filter(
    Signal <span class="dt">const</span>&amp; signal, Signal::size_type location, Signal <span class="dt">const</span>&amp; filter)
{
  <span class="kw">return</span> apply_cyclical_filter(
      signal.begin(), signal.begin() + location, signal.end(), filter);
}

Signal single_direct_transform(Signal <span class="dt">const</span>&amp; signal, DaubechyData <span class="dt">const</span>&amp; wavelet)
{
  Signal coefficients(number_of_coefficients(signal.size(), <span class="dv">1</span>));
  single_direct_transform(signal.begin(), signal.end(), coefficients.begin(), wavelet);
  <span class="kw">return</span> coefficients;
}

Signal direct_transform(
    Signal <span class="dt">const</span>&amp; signal, DaubechyData <span class="dt">const</span>&amp; wavelet, <span class="dt">unsigned</span> <span class="dt">int</span> levels)
{
  <span class="co">// shifting the bit left is the same as multiplying by two</span>
  Signal coefficients(number_of_coefficients(signal.size(), levels));
  direct_transform(signal.begin(), signal.end(), coefficients.begin(), wavelet, levels);
  <span class="kw">return</span> coefficients;
}

<span class="dt">unsigned</span> <span class="dt">int</span> number_of_coefficients(<span class="dt">unsigned</span> <span class="dt">int</span> signal_size, <span class="dt">unsigned</span> <span class="dt">int</span> levels)
{
  <span class="kw">if</span> (levels == <span class="dv">0</span>)
    <span class="kw">return</span> signal_size;
  <span class="dt">auto</span> <span class="dt">const</span> even_size = signal_size + signal_size % <span class="dv">2</span>;
  <span class="kw">if</span> (levels == <span class="dv">1</span>)
    <span class="kw">return</span> even_size;
  <span class="kw">return</span> even_size / <span class="dv">2</span> + number_of_coefficients(even_size / <span class="dv">2</span>, levels - <span class="dv">1</span>);
}

Scalar apply_cyclical_filter(
    Signal::const_iterator <span class="dt">const</span>&amp; start,
    Signal::const_iterator location,
    Signal::const_iterator <span class="dt">const</span>&amp; end,
    Signal <span class="dt">const</span>&amp; filter)
{
  <span class="kw">if</span> (start == end)
    <span class="kw">return</span> <span class="dv">0</span>;

  assert(location &gt;= start);
  assert(location &lt; end);

  Signal::value_type result(<span class="dv">0</span>);
  <span class="dt">auto</span> i_filter = filter.begin();
  <span class="kw">while</span> (i_filter != filter.end()) {
    <span class="kw">for</span> (; i_filter != filter.end() <span class="kw">and</span> location != end; ++i_filter, ++location)
      result += (*i_filter) * (*location);
    location = start;
  }
  <span class="kw">return</span> result;
}

<span class="dt">void</span> single_direct_transform(
    Signal::const_iterator <span class="dt">const</span>&amp; start, Signal::const_iterator <span class="dt">const</span>&amp; end,
    Signal::iterator <span class="dt">const</span> &amp;out, DaubechyData <span class="dt">const</span>&amp; wavelet)
{
  assert(start &lt;= end);
  <span class="dt">int</span> <span class="dt">const</span> half = ((end - start) + (end - start) % <span class="dv">2</span>) / <span class="dv">2</span>;
<span class="ot">#pragma omp parallel</span>
  {
<span class="ot">#pragma omp for</span>
    <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; half; ++i)
      *(out + i) = apply_cyclical_filter(start, start + <span class="dv">2</span> * i, end, wavelet.high_pass);
<span class="ot">#pragma omp for</span>
    <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; half; ++i)
      *(out + i + half) = apply_cyclical_filter(start, start + <span class="dv">2</span> * i, end, wavelet.low_pass);
  }
}

<span class="dt">void</span> direct_transform(
    Signal::const_iterator start, Signal::const_iterator end,
    Signal::iterator out, DaubechyData <span class="dt">const</span>&amp; wavelet,
    <span class="dt">unsigned</span> <span class="dt">int</span> levels)
{
  <span class="kw">if</span> (start == end)
    <span class="kw">return</span>

        assert(start &lt;= end);
  <span class="kw">if</span> (levels == <span class="dv">0</span>) {
    std::copy(start, end, out);
    <span class="kw">return</span>;
  }

  single_direct_transform(start, end, out, wavelet); <span class="co">// first iteration</span>

  <span class="dt">auto</span> <span class="dt">const</span> half = [](Signal::size_type n) { <span class="kw">return</span> (n + n % <span class="dv">2</span>) / <span class="dv">2</span>; };
  <span class="dt">auto</span> approx_size = half(end - start);
  Signal work_array(approx_size);
  <span class="dt">auto</span> <span class="dt">const</span> i_work = work_array.begin();
  <span class="kw">for</span> (<span class="dt">unsigned</span> <span class="dt">int</span> i(<span class="dv">1</span>); i &lt; levels; ++i, approx_size = half(approx_size)) {
    out += approx_size;
    std::copy(out, out + approx_size, i_work);
    single_direct_transform(i_work, i_work + approx_size, out, wavelet);
  }
}
}</code></pre>
</section></section>
    </div>
  </div>

  <script src="http://lab.hakim.se/reveal-js/lib/js/head.min.js"></script>
  <script src="http://lab.hakim.se/reveal-js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'night', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'http://lab.hakim.se/reveal-js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'http://lab.hakim.se/reveal-js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'http://lab.hakim.se/reveal-js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
