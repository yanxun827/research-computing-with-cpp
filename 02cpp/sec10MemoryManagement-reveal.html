<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Smart Pointers</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; }
code > span.dt { color: #dfdfbf; }
code > span.dv { color: #dcdccc; }
code > span.bn { color: #dca3a3; }
code > span.fl { color: #c0bed1; }
code > span.ch { color: #dca3a3; }
code > span.st { color: #cc9393; }
code > span.co { color: #7f9f7f; }
code > span.ot { color: #efef8f; }
code > span.al { color: #ffcfaf; }
code > span.fu { color: #efef8f; }
code > span.er { color: #c3bf9f; }
    </style>
    <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/theme/night.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//css/ucl_reveal.css"/>
    <link rel="stylesheet" href="/research-computing-with-cpp//site-styles/reveal.css"/>
  <link rel="stylesheet" media="print" href="http://lab.hakim.se/reveal-js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="http://lab.hakim.se/reveal-js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Smart Pointers</h1>
    <h3 class="date"></h3>
</section>

<section><section id="smart-pointers" class="titleslide slide level2"><h1>Smart Pointers</h1></section><section id="use-of-raw-pointers" class="slide level3">
<h1>Use of Raw Pointers</h1>
<ul>
<li>Given a pointer passed to a function</li>
</ul>
<pre><code>   void DoSomethingClever(int *a) 
   {
     // write some code
   }</code></pre>
<ul>
<li>How do we use the pointer?</li>
<li>What problems are there?</li>
</ul>
</section><section id="problems-with-raw-pointers" class="slide level3">
<h1>Problems with Raw Pointers</h1>
<ul>
<li>From <a href="https://www.amazon.co.uk/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1484571499&amp;sr=8-1&amp;keywords=Effective+Modern+C%2B%2B">&quot;Effective Modern C++&quot;, Meyers, p117</a>.
<ul>
<li>If you are done, do you destroy it?</li>
<li>How to destroy it? Call <code>delete</code> or some method first: <code>a-&gt;Shutdown();</code></li>
<li>Single object or array?</li>
<li><code>delete</code> or <code>delete[]</code>?</li>
<li>How to ensure the whole system only deletes it once?</li>
<li>Is it dangling, if I don't delete it?</li>
</ul></li>
</ul>
</section><section id="use-smart-pointers" class="slide level3">
<h1>Use Smart Pointers</h1>
<ul>
<li><code>new/delete</code> on raw pointers not good enough</li>
<li>So, use Smart Pointers
<ul>
<li>automatically delete pointed to object</li>
<li>explicit control over sharing</li>
<li>i.e. smarter</li>
</ul></li>
<li>Smart Pointers model the &quot;ownership&quot;</li>
</ul>
</section><section id="further-reading" class="slide level3">
<h1>Further Reading</h1>
<ul>
<li>Notes here are based on these:
<ul>
<li><a href="http://www.umich.edu/~eecs381/handouts/C++11_smart_ptrs.pdf">David Kieras online paper</a></li>
<li><a href="https://www.amazon.co.uk/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1484571499&amp;sr=8-1&amp;keywords=Effective+Modern+C%2B%2B">&quot;Effective Modern C++&quot;, Meyers, ch4</a></li>
</ul></li>
</ul>
</section><section id="standard-library-smart-pointers" class="slide level3">
<h1>Standard Library Smart Pointers</h1>
<ul>
<li>Here we teach Standard Library
<ul>
<li><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> - models <em>has-a</em> but also unique ownership</li>
<li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> - models <em>has-a</em> but shared ownership</li>
<li><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr">std::weak_ptr</a> - temporary reference, breaks circular references</li>
</ul></li>
</ul>
</section><section id="stack-allocated---no-leak." class="slide level3">
<h1>Stack Allocated - No Leak.</h1>
<ul>
<li>To recap:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="dt">int</span> main() {
  Fraction f(<span class="dv">1</span>,<span class="dv">4</span>);
}
</code></pre>
<ul>
<li>Gives:</li>
</ul>
<pre><code>I&#39;m being deleted
</code></pre>
<ul>
<li>So stack allocated objects are deleted, when stack unwinds.</li>
</ul>
</section><section id="heap-allocated---leak." class="slide level3">
<h1>Heap Allocated - Leak.</h1>
<ul>
<li>To recap:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="dt">int</span> main() {
  Fraction *f = <span class="kw">new</span> Fraction(<span class="dv">1</span>,<span class="dv">4</span>);
}
</code></pre>
<ul>
<li>Gives:</li>
</ul>
<pre><code></code></pre>
<ul>
<li>So heap allocated objects are not deleted.</li>
<li>Its the pointer (stack allocated) that's deleted.</li>
</ul>
</section><section id="unique-ptr---unique-ownership" class="slide level3">
<h1>Unique Ptr - Unique Ownership</h1>
<ul>
<li>So:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="ot">#include &lt;memory&gt;</span>
<span class="dt">int</span> main() {
  std::unique_ptr&lt;Fraction&gt; f(<span class="kw">new</span> Fraction(<span class="dv">1</span>,<span class="dv">4</span>));
}
</code></pre>
<ul>
<li>Gives:</li>
</ul>
<pre><code>I&#39;m being deleted
</code></pre>
<ul>
<li>And object is deleted.</li>
<li>Is that it?</li>
</ul>
</section><section id="unique-ptr---move" class="slide level3">
<h1>Unique Ptr - Move?</h1>
<ul>
<li>Does move work?</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="ot">#include &lt;memory&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main() {
  std::unique_ptr&lt;Fraction&gt; f(<span class="kw">new</span> Fraction(<span class="dv">1</span>,<span class="dv">4</span>));
  <span class="co">// std::unique_ptr&lt;Fraction&gt; f2(f); // compile error</span>

  std::cerr &lt;&lt; <span class="st">&quot;f=&quot;</span> &lt;&lt; f.get() &lt;&lt; std::endl;

  std::unique_ptr&lt;Fraction&gt; f2;
  <span class="co">// f2 = f; // compile error</span>
  <span class="co">// f2.reset(f.get()); // bad idea</span>

  f2.reset(f.release());
  std::cout &lt;&lt; <span class="st">&quot;f=&quot;</span> &lt;&lt; f.get() &lt;&lt; <span class="st">&quot;, f2=&quot;</span> &lt;&lt; f2.get() &lt;&lt; std::endl;

  f = std::move(f2);
  std::cout &lt;&lt; <span class="st">&quot;f=&quot;</span> &lt;&lt; f.get() &lt;&lt; <span class="st">&quot;, f2=&quot;</span> &lt;&lt; f2.get() &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>Gives:</li>
</ul>
<pre><code>f=0, f2=0x1f77010
f=0x1f77010, f2=0
I&#39;m being deleted
</code></pre>
<ul>
<li>We see that API makes difficult to use incorrectly.</li>
</ul>
</section><section id="unique-ptr---usage-1" class="slide level3">
<h1>Unique Ptr - Usage 1</h1>
<ul>
<li>Forces you to think about ownership
<ul>
<li>No copy constructor</li>
<li>No assignment</li>
</ul></li>
<li>Consequently
<ul>
<li>Can't pass pointer by value</li>
<li>Use move semantics for placing in containers</li>
</ul></li>
</ul>
</section><section id="unique-ptr---usage-2" class="slide level3">
<h1>Unique Ptr - Usage 2</h1>
<ul>
<li>Put raw pointer STRAIGHT into unique_ptr</li>
<li>see <code>std::make_unique</code> in C++14.</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="ot">#include &lt;memory&gt;</span>
<span class="dt">int</span> main() {
  std::unique_ptr&lt;Fraction&gt; f(<span class="kw">new</span> Fraction(<span class="dv">1</span>,<span class="dv">4</span>));
}
</code></pre>
</section><section id="shared-ptr---shared-ownership" class="slide level3">
<h1>Shared Ptr - Shared Ownership</h1>
<ul>
<li>Many pointers pointing to same object</li>
<li>Object only deleted if no pointers refer to it</li>
<li>Achieved via reference counting</li>
</ul>
</section><section id="shared-ptr-control-block" class="slide level3">
<h1>Shared Ptr Control Block</h1>
<ul>
<li><p>Won't go to too many details: <img src="https://www.safaribooksonline.com/library/view/effective-modern-c/9781491908419/assets/emcp_04in02.png" alt="Control Block"></p></li>
<li><p>From <a href="https://www.amazon.co.uk/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1484571499&amp;sr=8-1&amp;keywords=Effective+Modern+C%2B%2B">&quot;Effective Modern C++&quot;, Meyers, p140</a></p></li>
</ul>
</section><section id="shared-ptr---usage-1" class="slide level3">
<h1>Shared Ptr - Usage 1</h1>
<ul>
<li>Place raw pointer straight into shared_ptr</li>
<li>Pass to functions, reference or by value</li>
<li>Copy/Move constructors and assignment all implemented</li>
</ul>
</section><section id="shared-ptr---usage-2" class="slide level3">
<h1>Shared Ptr - Usage 2</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="ot">#include &lt;memory&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">void</span> divideBy2(<span class="dt">const</span> std::shared_ptr&lt;Fraction&gt;&amp; f)
{
  f-&gt;denominator *= <span class="dv">2</span>;
}
<span class="dt">void</span> multiplyBy2(<span class="dt">const</span> std::shared_ptr&lt;Fraction&gt; f)
{
  f-&gt;numerator *= <span class="dv">2</span>;
}
<span class="dt">int</span> main() {
  std::shared_ptr&lt;Fraction&gt; f1(<span class="kw">new</span> Fraction(<span class="dv">1</span>,<span class="dv">4</span>));
  std::shared_ptr&lt;Fraction&gt; f2 = f1;
  divideBy2(f1);
  multiplyBy2(f2);
  std::cout &lt;&lt; <span class="st">&quot;Value=&quot;</span> &lt;&lt; f1-&gt;numerator &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; f1-&gt;denominator &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="st">&quot;f1=&quot;</span> &lt;&lt; f1.get() &lt;&lt; <span class="st">&quot;, f2=&quot;</span> &lt;&lt; f2.get() &lt;&lt; std::endl;
}
</code></pre>
</section><section id="shared-ptr---usage-3" class="slide level3">
<h1>Shared Ptr - Usage 3</h1>
<ul>
<li>Watch out for exceptions.</li>
<li><a href="https://www.amazon.co.uk/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1484571499&amp;sr=8-1&amp;keywords=Effective+Modern+C%2B%2B">&quot;Effective Modern C++&quot;, Meyers, p140</a></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="ot">#include &lt;memory&gt;</span>
<span class="ot">#include &lt;stdexcept&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="dt">int</span> checkSomething(<span class="dt">const</span> std::shared_ptr&lt;Fraction&gt;&amp; f, <span class="dt">const</span> <span class="dt">int</span>&amp; i)
{
  <span class="co">// whatever.</span>
}
<span class="dt">int</span> computeSomethingFirst()
{
  <span class="co">// what if this throws?</span>
}
<span class="dt">int</span> main()
{
  std::vector&lt;std::shared_ptr&lt;Fraction&gt; &gt;  spaceForLotsOfFractions;
  <span class="dt">int</span> result = checkSomething(std::shared_ptr&lt;Fraction&gt;(<span class="kw">new</span> Fraction(<span class="dv">1</span>,<span class="dv">4</span>)),
                              computeSomethingFirst()
                             );
}</code></pre>
</section><section id="shared-ptr---usage-4" class="slide level3">
<h1>Shared Ptr - Usage 4</h1>
<ul>
<li>Prefer <code>std::make_shared</code></li>
<li>Exception safe</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="ot">#include &lt;memory&gt;</span>
<span class="ot">#include &lt;stdexcept&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="dt">int</span> checkSomething(<span class="dt">const</span> std::shared_ptr&lt;Fraction&gt;&amp; f, <span class="dt">const</span> <span class="dt">int</span>&amp; i)
{
  <span class="co">// whatever.</span>
}
<span class="dt">int</span> computeSomethingFirst()
{
  <span class="co">// what if this throws?</span>
}
<span class="dt">int</span> main()
{
  std::vector&lt;std::shared_ptr&lt;Fraction&gt; &gt;  spaceForLotsOfFractions;
  <span class="dt">int</span> result = checkSomething(std::make_shared&lt;Fraction&gt;(<span class="dv">1</span>,<span class="dv">4</span>),
                              computeSomethingFirst()
                             );
}</code></pre>
</section><section id="weak-ptr---why" class="slide level3">
<h1>Weak Ptr - Why?</h1>
<ul>
<li>Like a shared pointer, but doesn't actually own anything</li>
<li>Use for example:
<ul>
<li>Caches</li>
<li>Break circular pointers</li>
</ul></li>
<li>Limited API</li>
<li>Not terribly common as most code ends up as hierarchies</li>
</ul>
</section><section id="weak-ptr---example" class="slide level3">
<h1>Weak Ptr - Example</h1>
<ul>
<li>See <a href="http://www.umich.edu/~eecs381/handouts/C++11_smart_ptrs.pdf">David Kieras online paper</a></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Fraction.h&quot;</span>
<span class="ot">#include &lt;memory&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main() {
  std::shared_ptr&lt;Fraction&gt; s1(<span class="kw">new</span> Fraction(<span class="dv">1</span>,<span class="dv">4</span>));
  std::weak_ptr&lt;Fraction&gt; w1;      <span class="co">// can point to nothing</span>
  std::weak_ptr&lt;Fraction&gt; w2 = s1; <span class="co">// assignment from shared</span>
  std::weak_ptr&lt;Fraction&gt; w3(s1);  <span class="co">// construction from shared</span>

  <span class="co">// Can&#39;t be de-referenced!!!</span>
  <span class="co">// std::cerr &lt;&lt; &quot;Value=&quot; &lt;&lt; w1-&gt;numerator &lt;&lt; &quot;/&quot; &lt;&lt; w1-&gt;denominator &lt;&lt; std::endl;</span>

  <span class="co">// Needs converting to shared, and checking</span>
  std::shared_ptr&lt;Fraction&gt; s2 = w1.lock();
  <span class="kw">if</span> (s2)
  {
    std::cout &lt;&lt; <span class="st">&quot;Object w1 exists=&quot;</span> &lt;&lt; s2-&gt;numerator &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; s2-&gt;denominator &lt;&lt; std::endl;
  }

  <span class="co">// Or, create shared, check for exception</span>
  std::shared_ptr&lt;Fraction&gt; s3(w2);
  std::cout &lt;&lt; <span class="st">&quot;Object must exists=&quot;</span> &lt;&lt; s3-&gt;numerator &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; s3-&gt;denominator &lt;&lt; std::endl;
}
</code></pre>
</section><section id="final-advice" class="slide level3">
<h1>Final Advice</h1>
<ul>
<li>Benefits of immediate, fine-grained, garbage collection</li>
<li>Just ask <a href="https://www.amazon.co.uk/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1484571499&amp;sr=8-1&amp;keywords=Effective+Modern+C%2B%2B">Scott Meyers!</a>
<ul>
<li>Use <code>unique_ptr</code> for unique ownership</li>
<li>Easy to convert <code>unique_ptr</code> to <code>shared_ptr</code></li>
<li>But not the reverse</li>
<li>Use <code>shared_ptr</code> for shared resource management</li>
<li>Avoid raw <code>new</code> - use <code>make_shared</code>, <code>make_unique</code></li>
<li>Use <code>weak_ptr</code> for pointers that can dangle (cache etc)</li>
</ul></li>
</ul>
</section><section id="comment-on-boost" class="slide level3">
<h1>Comment on Boost</h1>
<ul>
<li>Boost has become a sandbox for standard C++</li>
<li>Boost features become part of standard C++, (different name space)</li>
<li>So if you are forced to use old compiler
<ul>
<li>You could use boost - lecture 5.</li>
</ul></li>
</ul>
</section><section id="intrusive-vs-non-intrusive" class="slide level3">
<h1>Intrusive Vs Non-Intrusive</h1>
<ul>
<li>Intrusive - Base class maintains a reference count eg. <a href="http://www.itk.org">ITK</a></li>
<li>Non-intrusive
<ul>
<li><code>std::unique_ptr</code></li>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
<li>works for any class</li>
</ul></li>
</ul>
</section><section id="itk-intrusive-smart-pointers" class="slide level3">
<h1>ITK (intrusive) Smart Pointers</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> MyFilter : <span class="co">// Other stuff</span>
{
<span class="kw">public</span>:
  <span class="kw">typedef</span> MyFilter Self
  <span class="kw">typedef</span> SmartPointer&lt;Self&gt; Pointer;
  itkNewMacro(Self);
<span class="kw">protected</span>:
  MyFilter();
  <span class="kw">virtual</span> ~MyFilter();
};

<span class="dt">double</span> someFunction(MyFilter::Pointer p)
{
  <span class="co">// stuff</span>
}

<span class="dt">int</span> main()
{
  MyFilter::Pointer p = itk::MyFilter::New();
}
</code></pre>
</section><section id="conclusion-for-smart-pointers" class="slide level3">
<h1>Conclusion for Smart Pointers</h1>
<ul>
<li>Default to standard library, check compiler</li>
<li>Lots of other Smart Pointers
<ul>
<li><a href="http://www.boost.org">Boost</a> (use STL).</li>
<li><a href="http://www.itk.org">ITK</a></li>
<li><a href="http://www.vtk.org/Wiki/VTK/Tutorials/SmartPointers">VTK</a></li>
<li><a href="https://wiki.qt.io/Smart_Pointers">Qt Smart Pointers</a></li>
</ul></li>
<li>Don't be tempted to write your own</li>
<li>Always read the manual</li>
<li>Always consistently use it</li>
</ul>
</section></section>
    </div>
  </div>

  <script src="http://lab.hakim.se/reveal-js/lib/js/head.min.js"></script>
  <script src="http://lab.hakim.se/reveal-js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'night', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'http://lab.hakim.se/reveal-js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'http://lab.hakim.se/reveal-js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'http://lab.hakim.se/reveal-js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'http://lab.hakim.se/reveal-js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
